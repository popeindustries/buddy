// Generated by CoffeeScript 1.3.1
var Builder, CONFIG, file, fs, log, path, target, term, trace;

fs = require('fs');

path = require('path');

log = console.log, trace = console.trace;

target = require('./target');

file = require('./file');

term = require('./terminal');

CONFIG = 'buddy.json';

module.exports = Builder = (function() {

  Builder.name = 'Builder';

  Builder.prototype.JS = 'js';

  Builder.prototype.CSS = 'css';

  Builder.prototype.RE_JS_SRC_EXT = /\.coffee$|\.js$/;

  Builder.prototype.RE_CSS_SRC_EXT = /\.styl$|\.less$/;

  Builder.prototype.RE_IGNORE_FILE = /^[\.|_]|[-|\.]min\.|svn|~$/;

  Builder.prototype.RE_BUILT_HEADER = /^\/\*BUILT/g;

  Builder.prototype.RE_ROOT = /^[a-zA-Z]\:\\\\?$|^\/$/;

  function Builder(version) {
    this.config = null;
    this.base = null;
    this.watching = false;
    this.jsSources = {
      locations: [],
      byPath: {},
      byModule: {},
      count: 0
    };
    this.cssSources = {
      locations: [],
      byPath: {},
      count: 0
    };
    this.jsTargets = [];
    this.cssTargets = [];
  }

  Builder.prototype.initialize = function(configpath) {
    var source, type, _i, _j, _len, _len1, _ref, _ref1;
    if (!this.initialized) {
      if (this._loadConfig(this._locateConfig(configpath))) {
        _ref = [this.JS, this.CSS];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          type = _ref[_i];
          if (this._validBuildType(type)) {
            _ref1 = this.config[type].sources;
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              source = _ref1[_j];
              this._parseSourceDirectory(path.resolve(this.base, source), null, this[type + 'Sources']);
            }
            this._parseTargets(this.config[type].targets, type);
          }
        }
        this.initialized = true;
      }
    }
    return this;
  };

  Builder.prototype.compile = function(compress, types) {
    var t, type, _i, _len, _results;
    if (types == null) {
      types = [this.JS, this.CSS];
    }
    _results = [];
    for (_i = 0, _len = types.length; _i < _len; _i++) {
      type = types[_i];
      if (this[type + 'Targets'].length) {
        _results.push((function() {
          var _j, _len1, _ref, _results1;
          _ref = this[type + 'Targets'];
          _results1 = [];
          for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
            t = _ref[_j];
            _results1.push(t.run(compress, this.watching));
          }
          return _results1;
        }).call(this));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  Builder.prototype.watch = function(compress) {
    var file, path, type, _i, _len, _ref, _results;
    if (!fs.watch) {
      return;
    }
    this.watching = true;
    this.compile(compress);
    _ref = [this.JS, this.CSS];
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      type = _ref[_i];
      if (this[type + 'Sources'].count) {
        term.out("watching for changes in " + (term.colour('[' + this.config[type].sources.join(', ') + ']', term.GREY)) + "...", 2);
        _results.push((function() {
          var _ref1, _results1;
          _ref1 = this[type + 'Sources'].byPath;
          _results1 = [];
          for (path in _ref1) {
            file = _ref1[path];
            _results1.push(this._watchFile(file, compress));
          }
          return _results1;
        }).call(this));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  Builder.prototype.deploy = function() {
    return this.compile(true);
  };

  Builder.prototype._locateConfig = function(configpath) {
    var dir, exists;
    if (configpath) {
      configpath = path.resolve(configpath);
      if (exists = path.existsSync(configpath)) {
        if (fs.statSync(configpath).isDirectory()) {
          configpath = path.join(configpath, CONFIG);
          exists = path.existsSync(configpath);
        }
      }
      if (!exists) {
        term.out("" + (term.colour('error', term.RED)) + " " + (term.colour(path.basename(configpath), term.GREY)) + " not found in " + (term.colour(path.dirname(configpath), term.GREY)), 2);
        return null;
      }
    } else {
      while (true) {
        dir = dir != null ? path.resolve(dir, '../') : process.cwd();
        configpath = path.join(dir, CONFIG);
        if (path.existsSync(configpath)) {
          break;
        }
        if (this.RE_ROOT.test(dir)) {
          term.out("" + (term.colour('error', term.RED)) + " " + (term.colour(CONFIG, term.GREY)) + " not found on this path", 2);
          return null;
        }
      }
    }
    return configpath;
  };

  Builder.prototype._loadConfig = function(configpath) {
    if (configpath) {
      term.out("loading config " + (term.colour(configpath, term.GREY)), 2);
      try {
        this.config = JSON.parse(fs.readFileSync(configpath, 'utf8'));
      } catch (e) {
        term.out("" + (term.colour('error', term.RED)) + " error parsing " + (term.colour(configpath, term.GREY)), 2);
        return false;
      }
      this.base = path.dirname(configpath);
      return true;
    } else {
      return false;
    }
  };

  Builder.prototype._validBuildType = function(type) {
    var _ref;
    return (((_ref = this.config[type]) != null ? _ref.sources : void 0) != null) && this.config[type].sources.length >= 1 && (this.config[type].targets != null) && this.config[type].targets.length >= 1;
  };

  Builder.prototype._parseSourceDirectory = function(dir, root, cache) {
    var f, item, itempath, _i, _len, _ref, _results;
    if (root === null) {
      root = dir;
      cache.locations.push(dir);
    }
    _ref = fs.readdirSync(dir);
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      item = _ref[_i];
      if (!item.match(this.RE_IGNORE_FILE)) {
        itempath = path.resolve(dir, item);
        if (fs.statSync(itempath).isDirectory()) {
          this._parseSourceDirectory(itempath, root, cache);
        }
        if (f = this._fileFactory(itempath, root)) {
          cache.byPath[f.filepath] = f;
          if (f.module != null) {
            cache.byModule[f.module] = f;
          }
          _results.push(cache.count++);
        } else {
          _results.push(void 0);
        }
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  Builder.prototype._fileFactory = function(filepath, base) {
    var contents;
    if (filepath.match(this.RE_JS_SRC_EXT)) {
      contents = fs.readFileSync(filepath, 'utf8');
      if (contents.match(this.RE_BUILT_HEADER)) {
        return null;
      }
      return new file.JSFile(this.JS, filepath, base, contents);
    } else if (filepath.match(this.RE_CSS_SRC_EXT)) {
      return new file.CSSFile(this.CSS, filepath, base);
    } else {
      return null;
    }
  };

  Builder.prototype._parseTargets = function(targets, type, parentTarget) {
    var item, t, _i, _len, _results;
    if (parentTarget == null) {
      parentTarget = null;
    }
    _results = [];
    for (_i = 0, _len = targets.length; _i < _len; _i++) {
      item = targets[_i];
      item.parent = parentTarget;
      if (t = this._targetFactory(type, item)) {
        this[type + 'Targets'].push(t);
        if (item.targets) {
          _results.push(this._parseTargets(item.targets, type, t));
        } else {
          _results.push(void 0);
        }
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  Builder.prototype._targetFactory = function(type, options) {
    var dir, inSources, inputpath, location, outputpath, _i, _len, _ref;
    inputpath = path.resolve(this.base, options["in"]);
    outputpath = path.resolve(this.base, options.out);
    if (!path.existsSync(inputpath)) {
      term.out("" + (term.colour('error', term.RED)) + " " + (term.colour(options["in"], term.GREY)) + " not found in project path", 2);
      return null;
    }
    _ref = this[type + 'Sources'].locations;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      location = _ref[_i];
      dir = fs.statSync(inputpath).isDirectory() ? inputpath : path.dirname(inputpath);
      inSources = dir.indexOf(location) >= 0;
      if (inSources) {
        break;
      }
    }
    if (!inSources) {
      term.out("" + (term.colour('error', term.RED)) + " " + (term.colour(options["in"], term.GREY)) + " not found in source path", 2);
      return null;
    }
    if (fs.statSync(inputpath).isDirectory() && path.extname(outputpath).length) {
      term.out("" + (term.colour('error', term.RED)) + " a file (" + (term.colour(options.out, term.GREY)) + ") is not a valid output target for a directory (" + (term.colour(options["in"], term.GREY)) + ") input target", 2);
      return null;
    }
    return new target[type.toUpperCase() + 'Target'](inputpath, outputpath, this[type + 'Sources'], options.nodejs, options.parent);
  };

  Builder.prototype._watchFile = function(file, compress) {
    var callback, stat, watcher,
      _this = this;
    stat = fs.statSync(file.filepath);
    file.lastChange = +stat.mtime;
    file.lastSize = stat.size;
    return watcher = fs.watch(file.filepath, callback = function(event) {
      var last, nstat;
      if (event === 'rename') {
        watcher.close();
        try {
          watcher = fs.watch(file.filepath, callback);
        } catch (_error) {}
      }
      if (event === 'change') {
        nstat = fs.statSync(file.filepath);
        last = +nstat.mtime / 1000;
        if (last !== file.lastChange) {
          file.lastChange = last;
          term.out("[" + (new Date().toLocaleTimeString()) + "] change detected in " + (term.colour(file.filename, term.GREY)), 0);
          file.updateContents(fs.readFileSync(file.filepath, 'utf8'));
          return _this.compile(compress, [file.type]);
        }
      }
    });
  };

  return Builder;

})();
