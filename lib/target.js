// Generated by CoffeeScript 1.3.1
var CSSTarget, JSTarget, Target, coffee, file, fs, growl, less, log, path, stylus, term, uglify,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

fs = require('fs');

path = require('path');

term = require('./terminal');

coffee = require('coffee-script');

stylus = require('stylus');

less = require('less');

uglify = require('uglify-js');

growl = require('growl');

file = require('./file');

log = console.log;

exports.Target = Target = (function() {

  Target.name = 'Target';

  function Target(input, output, cache) {
    this.input = input;
    this.output = output;
    this.cache = cache;
    this.compress = false;
    this.batch = null;
    this.sources = [];
  }

  Target.prototype.initialize = function() {
    if (this._validInput(this.input)) {
      this.sources = [];
      if (this.batch === null) {
        this.batch = fs.statSync(this.input).isDirectory();
      }
      if (!path.extname(this.output).length && fs.statSync(this.input).isFile()) {
        this.output = path.join(this.output, path.basename(this.input)).replace(path.extname(this.input), this.EXTENSION);
      }
      this._parseInput(this.input);
    } else {
      term.out("" + (term.colour('warning', term.YELLOW)) + " input location does not exist " + (term.colour(this.input, term.GREY)), 2);
    }
    return this;
  };

  Target.prototype.run = function(compress) {
    this.compress = compress;
    if (this.sources.length) {
      term.out("building " + (term.colour(path.basename(this.input), term.GREY)) + " to " + (term.colour(path.basename(this.output), term.GREY)), 2);
      return this._build();
    } else {
      return term.out("" + (term.colour('warning', term.YELLOW)) + " no sources to build in " + (term.colour(this.input, term.GREY)), 2);
    }
  };

  Target.prototype.hasSource = function(file) {
    return __indexOf.call(this.sources, file) >= 0;
  };

  Target.prototype._validInput = function(input) {
    return fs.existsSync(input);
  };

  Target.prototype._parseInput = function(input) {
    var f, item, _i, _len, _ref, _results;
    if (fs.statSync(input).isFile()) {
      if (f = this.cache.byPath[input]) {
        return this._addSource(f);
      }
    } else {
      _ref = fs.readdirSync(input);
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        _results.push(this._parseInput(path.join(input, item)));
      }
      return _results;
    }
  };

  Target.prototype._addSource = function(file) {
    if (__indexOf.call(this.sources, file) < 0) {
      return this.sources.push(file);
    }
  };

  Target.prototype._makeDirectory = function(filepath) {
    var dir;
    dir = path.dirname(filepath);
    if (!fs.existsSync(dir)) {
      try {
        return fs.statSync(dir).isDirectory();
      } catch (error) {
        if (error.code === 'ENOENT') {
          this._makeDirectory(dir);
          return fs.mkdirSync(dir);
        }
      }
    }
  };

  Target.prototype._notifyError = function(filepath, error) {
    term.out("" + (term.colour('error', term.RED)) + " building " + (term.colour(path.basename(filepath), term.GREY)) + ": " + error, 4);
    try {
      return growl.notify("error building " + filepath + ": " + error, {
        title: 'BUDDY'
      });
    } catch (_error) {}
  };

  return Target;

})();

exports.JSTarget = JSTarget = (function(_super) {

  __extends(JSTarget, _super);

  JSTarget.name = 'JSTarget';

  JSTarget.prototype.BUILT_HEADER = '/*BUILT ';

  JSTarget.prototype.REQUIRE = 'require.js';

  JSTarget.prototype.EXTENSION = '.js';

  JSTarget.prototype.ERROR_LINE_NUMBER = 4;

  JSTarget.prototype.RE_COFFEE_HELPERS = /^(\s+)(__\w*)\s=\s(.+)(,|;)$/gm;

  JSTarget.prototype.RE_COMPILE_ERROR_LINE = /line\s(\d+)/gi;

  function JSTarget(input, output, cache, nodejs, parentTarget) {
    this.nodejs = nodejs != null ? nodejs : false;
    this.parentTarget = parentTarget != null ? parentTarget : null;
    JSTarget.__super__.constructor.call(this, input, output, cache);
  }

  JSTarget.prototype.initialize = function() {
    if (this.nodejs) {
      this.batch = true;
    }
    return JSTarget.__super__.initialize.call(this);
  };

  JSTarget.prototype._addSource = function(file, dependantFile) {
    var dep, dependency, _i, _len, _ref, _ref1;
    if ((_ref = this.parentTarget) != null ? _ref.hasSource(file) : void 0) {
      return;
    }
    if (file.dependencies.length) {
      _ref1 = file.dependencies;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        dependency = _ref1[_i];
        if ((dependantFile != null ? dependantFile.module : void 0) !== dependency) {
          if (dep = this.cache.byModule[dependency] || this.cache.byModule["" + dependency + "/index"]) {
            this._addSource(dep, file);
          } else {
            term.out("" + (term.colour('warning', term.YELLOW)) + " dependency " + (term.colour(dependency, term.GREY)) + " for " + (term.colour(file.module, term.GREY)) + " not found", 4);
          }
        }
      }
    }
    if (file.filepath === this.input && !this.batch) {
      file.main = true;
    }
    return JSTarget.__super__._addSource.call(this, file);
  };

  JSTarget.prototype._build = function() {
    var c, content, contents, f, filepath, _i, _j, _len, _len1, _ref, _ref1;
    if (this.batch) {
      _ref = this.sources;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        f = _ref[_i];
        filepath = path.extname(this.output).length ? this.output : path.join(this.output, f.name) + this.EXTENSION;
        content = f.compile ? this._compile(f.contents, filepath) : f.contents;
        if (content != null) {
          if (!this.nodejs) {
            content = f.wrap(content);
          }
          this._writeFile(content, filepath, false);
        }
      }
      return true;
    } else {
      contents = [];
      _ref1 = this.sources;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        f = _ref1[_j];
        c = f.compile ? this._compile(f.contents, f.filepath) : f.contents;
        contents.push(f.wrap(c));
      }
      content = contents.join('\n');
      if (content != null) {
        if (!(this.nodejs || this.parentTarget)) {
          content = "" + (fs.readFileSync(path.join(__dirname, this.REQUIRE), 'utf8')) + "\n" + content;
        }
        this._writeFile(this._optimizeAndWrap(content), this.output, true);
        return true;
      } else {
        return null;
      }
    }
  };

  JSTarget.prototype._compile = function(content, filepath) {
    var high, l, line, lineNo, lines, low, match, _i, _len, _ref;
    try {
      return coffee.compile(content, {
        bare: true
      });
    } catch (error) {
      this._notifyError(filepath, error);
      if (match = this.RE_COMPILE_ERROR_LINE.exec(error)) {
        lineNo = +match[1] - 1;
        lines = content.split('\n');
        low = Math.max(lineNo - this.ERROR_LINE_NUMBER, 0);
        high = Math.min(lineNo + this.ERROR_LINE_NUMBER, lines.length - 1);
        l = low;
        _ref = lines.slice(low, high + 1 || 9e9);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          line = _ref[_i];
          if (l++ === lineNo) {
            term.out("" + (term.colour('> ' + l + ' ' + line, term.RED)), 4);
          } else {
            term.out("" + (term.colour(l + ' ' + line, term.GREY)), 5);
          }
        }
      }
      return null;
    }
  };

  JSTarget.prototype._writeFile = function(content, filepath, header) {
    this._makeDirectory(filepath);
    term.out("" + (term.colour('built', term.GREEN)) + " " + (term.colour(path.basename(filepath), term.GREY)), 4);
    if (this.compress) {
      this._compress(filepath, content, header);
    } else {
      if (header) {
        content = this._addHeader(content);
      }
      fs.writeFileSync(filepath, content, 'utf8');
    }
    return true;
  };

  JSTarget.prototype._compress = function(filepath, contents, header) {
    var ast, compressed, jsp, pro;
    jsp = uglify.parser;
    pro = uglify.uglify;
    ast = jsp.parse(contents);
    ast = pro.ast_mangle(ast);
    ast = pro.ast_squeeze(ast);
    compressed = pro.gen_code(ast);
    if (header) {
      compressed = this._addHeader(compressed);
    }
    fs.writeFileSync(filepath, compressed);
    return term.out("" + (term.colour('compressed', term.GREEN)) + " " + (term.colour(path.basename(filepath), term.GREY)), 4);
  };

  JSTarget.prototype._optimizeAndWrap = function(contents) {
    var expr, replaceSnippet, snippet, snippets;
    snippets = {};
    replaceSnippet = function(str, p1, p2, p3, p4) {
      snippets[p2] = p3.replace('__', '___');
      return "" + p1 + p2 + " = _" + p2 + p4;
    };
    contents = contents.replace(this.RE_COFFEE_HELPERS, replaceSnippet);
    return "(function () {\n" + (((function() {
      var _results;
      _results = [];
      for (snippet in snippets) {
        expr = snippets[snippet];
        _results.push('  var _' + snippet + ' = ' + expr);
      }
      return _results;
    })()).join(';\n')) + ";\n" + contents + "\n}).call(this);";
  };

  JSTarget.prototype._addHeader = function(content) {
    return "" + this.BUILT_HEADER + (new Date().toString()) + "*/\n" + content;
  };

  return JSTarget;

})(Target);

exports.CSSTarget = CSSTarget = (function(_super) {

  __extends(CSSTarget, _super);

  CSSTarget.name = 'CSSTarget';

  CSSTarget.prototype.EXTENSION = '.css';

  function CSSTarget(input, output, cache) {
    CSSTarget.__super__.constructor.call(this, input, output, cache);
  }

  CSSTarget.prototype._build = function() {
    var f, filepath, _i, _len, _ref;
    if (this.batch) {
      _ref = this.sources;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        f = _ref[_i];
        filepath = path.join(this.output, f.name) + this.EXTENSION;
        if (f.compile) {
          this._compile(f.contents, filepath, path.extname(f.filepath));
        } else {
          this._writeFile(f.contents, filepath);
        }
      }
      return true;
    } else {
      f = this.sources[0];
      return this._compile(f.contents, this.output, path.extname(f.filepath));
    }
  };

  CSSTarget.prototype._compile = function(content, filepath, extension) {
    var parser, stylc,
      _this = this;
    if (file.CSSFile.prototype.RE_STYLUS_EXT.test(extension)) {
      stylc = stylus(content).set('paths', this.cache.locations.concat());
      if (this.compress) {
        stylc.set('compress', true);
      }
      return stylc.render(function(error, css) {
        if (error) {
          _this._notifyError(filepath, error);
          return null;
        } else {
          return _this._writeFile(css, filepath);
        }
      });
    } else if (file.CSSFile.prototype.RE_LESS_EXT.test(extension)) {
      parser = new less.Parser({
        paths: this.cache.locations.concat()
      });
      return parser.parse(content, function(error, tree) {
        if (error) {
          _this._notifyError(filepath, error);
          return null;
        } else {
          return _this._writeFile(tree.toCSS({
            compress: _this.compress
          }), filepath);
        }
      });
    }
  };

  CSSTarget.prototype._writeFile = function(content, filepath) {
    this._makeDirectory(filepath);
    term.out("" + (term.colour('built', term.GREEN)) + " " + (term.colour(path.basename(filepath), term.GREY)), 4);
    fs.writeFileSync(filepath, content, 'utf8');
    return true;
  };

  return CSSTarget;

})(Target);
